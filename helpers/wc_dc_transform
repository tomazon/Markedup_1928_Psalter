#! env perl

use strict;
use warnings;

use File::Slurp;
use String::Diff qw( diff );
use YAML;

use feature 'say';


my %ansi = (
    red          => "\e[0;31m",
    green        => "\e[0;32m",
    yellow       => "\e[0;33m",
    blue         => "\e[0;34m",
    bright_red   => "\e[1;31m",
    bright_green => "\e[1;32m",
    on_red       => "\e[1;41m",
    on_green     => "\e[1;42m",
    on_yellow    => "\e[1;43m",
    reset        => "\e[0m",
);

my $in_file  = "./yaml/psalms.yaml";
my $out_file = "./helpers/wc_dc_transform.out.yaml";
my $log_file = "./helpers/wc_dc_transform.log";


my $data = YAML::LoadFile($in_file);
open (my $log_fh, ">$log_file") || die "Can't open $log_file for writing: $!\n";

for my $psalm_num (sort keys %{$data->{psalm}}) {
    my $psalm = $data->{psalm}->{$psalm_num};
    for my $part_num (sort keys %{$psalm->{part}}) {
        my $part = $psalm->{part}->{$part_num};
        for my $verse_num (sort keys %{$part->{verse}}) {
            my $verse = $part->{verse}->{$verse_num};
            next unless $verse =~ /,/;
            log_it($log_fh, join(':', $psalm_num, $verse_num));
            my $new = transform_verse($verse);
            my $diff = String::Diff::diff($verse, $new,
                remove_open =>  "$ansi{red}",
                remove_close => "$ansi{reset}",
                append_open =>  "$ansi{green}",
                append_close => "$ansi{reset}",
            );
            log_it($log_fh, "     -  $diff->[0]");
            log_it($log_fh, "     +  $diff->[1]");
            store_verse($data, $psalm_num, $part_num, $verse_num, $new);
        }
    }

}

say YAML::DumpFile($out_file, $data);

####################################################################################################

sub log_it {
    my ($log_fh, $text) = @_;
    print $log_fh "$text\n" || die "Error writing to $log_fh\n";
    print STDERR  "$text\n";
}

sub transform_verse {
    my ($text) = @_;

    $text =~ s/\{dc}\{wc},/[C:D:W:S]/g;
    $text =~ s/{dc},/[C:D:S]/g;
    $text =~ s/{wc},/[C:W:S]/g;
    $text =~ s/,/[C:S]/g;

    $text =~ s/\[C:D:W:S\]/,/g;
    $text =~ s/\[C:D:S\]/{wc},/g;
    $text =~ s/\[C:W:S\]/{dc},/g;
    $text =~ s/\[C:S\]/{dc}{wc},/g;

    $text;
}

sub store_verse {
    my ($data, $psalm_num, $part_num, $verse_num, $text) = @_;
    $data->{psalm}->{$psalm_num}->{part}->{$part_num}->{verse}->{$verse_num} = $text;
}
